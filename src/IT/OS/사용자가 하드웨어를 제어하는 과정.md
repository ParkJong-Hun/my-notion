# 사용자가 하드웨어를 제어하는 과정

1. 사용자 입력
2. 사용자 인터페이스 처리
    1. Shell 또는 GUI로 사용자 입력 해석
    2. 해당 동작에 필요한 프로그램/명령어 식별
3. 시스템 콜 호출
    1. 응용 프로그램이 커널에게 하드웨어 접근을 요청
        1. 저레벨 프로그래밍 언어의 `open`, `read`, `write`, `close` 등
            1. 해당 콜 인터페이스의 처리는 OS의 어셈블리 레벨에서 실행됨
                
                ```nasm
                ; open() 시스템 콜 (Linux x86_64 기준)
                mov rax, 2          ; sys_open 시스템 콜 번호
                mov rdi, filename   ; 첫 번째 인자: 파일명 포인터
                mov rsi, O_RDONLY   ; 두 번째 인자: 플래그
                mov rdx, 0          ; 세 번째 인자: 권한
                syscall             ; 커널 모드로 전환
                ```
                
    2. 사용자 모드에서 커널 모드로 전환
4. 커널 처리
    1. 커널이 요청을 검증하고 권한 확인
    
    ```c
    // 커널 내부 함수 (의사코드)
    int sys_open(const char *pathname, int flags, mode_t mode) {
        // 1. 사용자 권한 확인
        if (!check_file_permissions(current_user, pathname, flags)) {
            return -EACCES;  // 권한 거부
        }
        
        // 2. 파일 시스템 경로 해석
        struct path path;
        if (path_lookup(pathname, &path) < 0) {
            return -ENOENT;  // 파일 없음
        }
        
        // 3. 파일 디스크립터 할당
        int fd = get_unused_fd();
        
        // 4. 파일 구조체 생성
        struct file *filp = filp_open(pathname, flags, mode);
        
        // 5. 프로세스 파일 테이블에 등록
        current->files->fd_array[fd] = filp;
        
        return fd;
    }
    ```
    
    1. 필요한 하드웨어 자원을 할당하고 관리
    2. 메모리, CPU, 저장장치 등에 접근
        
        ```c
        // 읽기 요청 처리
        ssize_t sys_read(int fd, void *buf, size_t count) {
            // 1. 파일 디스크립터 유효성 검사
            struct file *filp = get_file(fd);
            if (!filp) return -EBADF;
            
            // 2. 사용자 메모리 영역 검증
            if (!access_ok(buf, count)) return -EFAULT;
            
            // 3. 페이지 캐시 확인
            struct page *page = find_get_page(filp->mapping, offset >> PAGE_SHIFT);
            
            // 4. 캐시 미스 시 디스크에서 읽기
            if (!page) {
                page = read_from_disk(filp, offset);
            }
            
            // 5. 커널 공간에서 사용자 공간으로 데이터 복사
            copy_to_user(buf, page_data, count);
            
            return count;
        }
        ```
        
5. 하드웨어 제어
    1. 디바이스 드라이버를 통해 실제 하드웨어와 통신
        
        ```c
        // 블록 디바이스 읽기 요청
        static int sata_read_sectors(struct block_device *bdev, 
                                    sector_t sector, void *buffer, int count) {
            // 1. 하드웨어 레지스터 설정
            outl(sector & 0xFF, ATA_REG_LBA0);          // LBA 주소 설정
            outl((sector >> 8) & 0xFF, ATA_REG_LBA1);
            outl((sector >> 16) & 0xFF, ATA_REG_LBA2);
            outl(count, ATA_REG_SECTOR_COUNT);          // 읽을 섹터 수
            outb(ATA_CMD_READ_SECTORS, ATA_REG_COMMAND); // 읽기 명령 전송
            
            // 2. 하드웨어 응답 대기
            while (!(inb(ATA_REG_STATUS) & ATA_STATUS_DRQ)) {
                if (inb(ATA_REG_STATUS) & ATA_STATUS_ERR) {
                    return -EIO;  // 하드웨어 오류
                }
                cpu_relax();  // CPU 양보
            }
            
            // 3. 데이터 포트에서 데이터 읽기
            insw(ATA_REG_DATA, buffer, SECTOR_SIZE * count / 2);
            
            return 0;
        }
        ```
        
    2. 하드웨어가 실제 작업 수행
6. 결과 반환

<aside>
💡

OS는 주로 C 언어를 사용.

주로 아래와 같은 경우 어셈블리어가 사용됨. (전체의 1.5%)

C로는 접근할 수 없는 특수 CPU 레지스터나 명령어를 사용해야 할 때 (ex/ 인터럽트 핸들러 진입점)

극한의 성능 최적화

(ex/ 암호화, 코덱, 물리 연산 등)

부팅 및 초기화 (C 실행 환경이 없기 때문에)

(ex/ 부트 로더 (시스템 시작))

컨텍스트 스위칭 (정확한 레지스터 저장/복원을 위해)

</aside>